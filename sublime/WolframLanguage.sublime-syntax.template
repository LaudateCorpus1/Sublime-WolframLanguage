%YAML 1.2
---

# https://www.sublimetext.com/docs/3/syntax.html
# https://www.sublimetext.com/docs/3/scope_naming.html

#
# Adapted from: https://github.com/ViktorQvarfordt/Sublime-WolframLanguage
#

name: WolframLanguage

file_extensions:
  - m
  - wl
  - wls
  - mt
  - wlt

scope: source.wolfram

variables:
  symbolSegment: (?:[$[:alpha:]][$[:alnum:]]*)
  symbolEndBoundary: (?![<*"`"*>$[:alnum:]])

  #
  # These get filled-in during build
  #
  built_in_functions: (?:`builtInFunctions`)
  constants: (?:`constants`)
  obsolete_functions: (?:`obsoleteFunctions`)
  undocumented_functions: (?:`undocumentedFunctions`)
  experimental_functions: (?:`experimentalFunctions`)
  long_names: (?:`longNames`)

  punctuation_char: (?:!|&|'|\*|\+|,|-|\.|/|:|;|<|=|>|\?|@|\\|^|\||~)


contexts:

  main:
    - include: simple_toplevel_constants
    - include: toplevel_options
    - include: toplevel_attributes
    - include: simple_toplevel_definitions
    - include: expressions

  simple_toplevel_constants:
    - match: '{{symbolSegment}}(?=\s*(?::=|=))'
      scope:
        entity.name.constant.wolfram

  toplevel_options:
    - match: (Options)\s*\[\s*({{symbolSegment}})\s*\](?=\s*(:=|=))
      captures:
        1: variable.function.builtin.wolfram
        2: entity.other.Options.wolfram

  toplevel_attributes:
    - match: (Attributes)\s*\[\s*({{symbolSegment}})\s*\](?=\s*(:=|=))
      captures:
        1: variable.function.builtin.wolfram
        2: entity.other.Attributes.wolfram

  #
  # The general syntax of WL allows full expressions to appear on the LHS of a function definition,
  # and this would greatly complicate syntax highlighting
  #
  # So take a simpler approach and only allow symbol segments, followed by [], which may contain any valid syntax
  #
  # This is not a complete solution to highlighting functions in WL
  #
  simple_toplevel_definitions:
    - match: |-
        (?x)
        {{symbolSegment}} (?# head foo in definition foo[] := 2+2 )
        (?= (?# positive lookahead )
          \s*
          (?#
          we are looking ahead and do not care about highlighting anything here
          we just need to match balanced groups of [] so that we know when the outer group is done and we can look for :=
          the following setup allows groups of balanced [] to be matched
          )
          ( (?# relative group #1 from the \g )
            \[
            (?> (?# atomic group for efficiency. this group is non-capturing and does not count for \g )
              [^\[\]]+ (?# match any character that is not [ or ] )
              | (?# or )
              \g<-1> (?# call subexp in relative group #1 )
            )*
            \]
          )
          \s*
          (?::=|=) (?# SetDelayed or Set )
        )
      scope:
        meta.function.wolfram entity.name.function.wolfram

  expressions:
    - include: comments
    - include: escaped_characters
    #
    # out and slot are ahead of literals, to allow
    # #1 and %1 to match before 1
    #
    - include: out
    - include: slot
    - include: literals
    #
    # groups ahead of operators, to allow
    # <| and |> to match before < and |
    #
    - include: groups
    - include: stringifying_operators
    - include: operators
    - include: pattern_operators
    - include: symbols
    #
    # Anything else is an error
    #
    - match: '{{punctuation_char}}'
      scope: invalid.illegal

  comments:
    - match: \(\*
      scope: punctuation.definition.comment.wolfram
      push: comment-block
    - match: \*\)
      scope: invalid.illegal.stray-comment-end.wolfram

  comment-block:
    - meta_scope: comment.block.wolfram
    - match: \(\*
      scope: punctuation.definition.comment.wolfram
      push: comment-block
    - match: \*\)
      scope: punctuation.definition.comment.wolfram
      pop: true
    #
    # Emit a separate token for each character in comment
    # This has the result of disabling ligatures inside comments
    #
    - match: .

  escaped_characters:
    #
    # linear syntax
    #
    - match: \\[!%&()*+/@^_<*"`"*> ]
      scope: constant.character.escape

    #
    # Long Names
    #
    - match: \\\[{{long_names}}\]
      scope: constant.character.escape
    #
    # Anything else is an error
    #
    - match: \\\[.*\]
      scope: invalid.illegal

    #
    # \:XXXX syntax
    #
    - match: \\:\h\h\h\h
      scope: constant.character.escape
    #
    # \.XX syntax
    #
    - match: \\\.\h\h
      scope: constant.character.escape
    #
    # \|XXXXXX syntax
    #
    - match: \\\|\h\h\h\h\h\h
      scope: constant.character.escape
    #
    # \XXX syntax
    #
    - match: \\[0-7][0-7][0-7]
      scope: constant.character.escape
    # line continuation
    - match: \\$
      scope: constant.character.escape punctuation.separator.continuation
    #
    # Anything else is an error
    #
    - match: \\.
      scope: invalid.illegal

  string_escaped_characters:
    - match: \\[bfnrt"\\<>]
      scope: constant.character.escape
    - include: escaped_characters

  literals:
    - match: 16\^\^\h+
      scope: constant.numeric.wolfram
    - match: (?:\d+\.?|\.\d)\d*\<*"`"*>{0,2}
      scope: constant.numeric.wolfram
    - match: \"
      scope: punctuation.definition.string.begin
      push:
        - meta_scope: string.quoted.double.wolfram
        - match: \"
          scope: punctuation.definition.string.end
          pop: true
        - include: string_escaped_characters
        #
        # Emit a separate token for each character in string
        # This has the result of disabling ligatures inside strings
        #
        - match: .

  stringifying_operators:
    - match: (>>>)\s*("\w*")
      captures:
        1: keyword.operator.PutAppend.wolfram
        2: string.quoted.double.wolfram
    - match: (>>>)\s*(\w+)
      captures:
        1: keyword.operator.PutAppend.wolfram
        2: string.unquoted.wolfram
    - match: '>>>'
      scope: invalid.illegal
    - match: (::)("[[:alpha:]][[:alnum:]]*")
      captures:
        1: keyword.operator.MessageName.wolfram
        2: string.quoted.double.wolfram
    - match: (::)([[:alpha:]][[:alnum:]]*)
      captures:
        1: keyword.operator.MessageName.wolfram
        2: string.unquoted.wolfram
    - match: '::'
      scope: invalid.illegal
    - match: (<<)\s*("[<*"`"*>[:alpha:]][<*"`"*>[:alnum:]]*")
      captures:
        1: keyword.operator.Get.wolfram
        2: string.quoted.double.wolfram
    - match: (<<)\s*([<*"`"*>[:alpha:]][<*"`"*>[:alnum:]]*)
      captures:
        1: keyword.operator.Get.wolfram
        2: string.unquoted.wolfram
    - match: '<<'
      scope: invalid.illegal
    - match: (>>)\s*("\w*")
      captures:
        1: keyword.operator.Put.wolfram
        2: string.quoted.double.wolfram
    - match: (>>)\s*(\w+)
      captures:
        1: keyword.operator.Put.wolfram
        2: string.unquoted.wolfram
    - match: '>>'
      scope: invalid.illegal

  operators:
    # 3 character assignment
    - match: (?:\^:=)
      scope: keyword.operator.assignment.UpSetDelayed.wolfram
    # anything else after ^:
    - match: (?:\^:)
      scope: invalid.illegal
    # 3 character other
    - match: (?:===)
      scope: keyword.operator.SameQ.wolfram
    - match: (?:=!=|\.\.\.|//\.|@@@|<->|//@)
      scope: keyword.operator.wolfram
    # 2 character arithmetic
    - match: (?:--|\+\+)
      scope: keyword.operator.arithmetic.wolfram
    # 2 character logical
    - match: (?:\|\||&&)
      scope: keyword.operator.logical.wolfram
    # 2 character assignment
    - match: (?::=)
      scope: keyword.operator.assignment.SetDelayed.wolfram
    - match: (?:\^=)
      scope: keyword.operator.assignment.UpSet.wolfram
    - match: (?:/=)
      scope: keyword.operator.assignment.DivideBy.wolfram
    - match: (?:\+=)
      scope: keyword.operator.assignment.AddTo.wolfram
    - match: (?:=\.)
      scope: keyword.operator.assignment.Unset.wolfram
    - match: (?:\*=)
      scope: keyword.operator.assignment.TimesBy.wolfram
    - match: (?:-=)
      scope: keyword.operator.assignment.SubtractFrom.wolfram
    # could be TagSet, TagSetDelayed, or TagUnset, so do not specify
    - match: (?:/:)
      scope: keyword.operator.assignment.Tag.wolfram
    # 2 character ;; specific
    - match: (?:;;)$
      scope: invalid.endofline.Span.wolfram
    - match: (?:;;)
      scope: keyword.operator.Span.wolfram
    # 2 character other
    - match: (?:!=)
      scope: keyword.operator.Unequal.wolfram
    - match: (?:==)
      scope: keyword.operator.Equal.wolfram
    # could be Factorial2 or Not2, so do not treat as logical
    - match: (?:!!)
      scope: keyword.operator.BangBang.wolfram
    - match: (?:\?\?)
      scope: invalid.illegal.Information.wolfram
    - match: (?:<=|>=|\.\.|:>|<>|->|/@|/;|/\.|//|/\*|@@|@\*|~~|\*\*)
      scope: keyword.operator.wolfram
    # 1 character arithmetic
    - match: (?:-|\+|/|\*)
      scope: keyword.operator.arithmetic.wolfram
    # 1 character assignment
    - match: (?:=)
      scope: keyword.operator.assignment.Set.wolfram
    # 1 character other
    - match: (?:<)
      scope: keyword.operator.Less.wolfram
    - match: (?:\|)
      scope: keyword.operator.Alternatives.wolfram
    # could be Not or Factorial, so do not treat as logical
    - match: (?:!)
      scope: keyword.operator.Bang.wolfram
    - match: (?:;)
      scope: keyword.operator.CompoundExpression.wolfram punctuation.terminator
    - match: (?:,)
      scope: keyword.operator.Comma.wolfram punctuation.separator
    - match: ^(?:\?)
      scope: invalid.startofline.Information.wolfram
    - match: (?:\?)
      scope: keyword.operator.PatternTest.wolfram
    - match: (?:')
      scope: keyword.operator.Derivative.wolfram
    - match: (?:>|\^|\.|:|,|&|@|~)
      scope: keyword.operator.wolfram

  symbols:
    # recognized System<*"`"*> qualified symbols
    - match: System<*"`"*>{{built_in_functions}}{{symbolEndBoundary}}
      scope: variable.function.builtin.wolfram
    - match: System<*"`"*>{{constants}}{{symbolEndBoundary}}
      scope: constant.language.wolfram
    - match: System<*"`"*>{{obsolete_functions}}{{symbolEndBoundary}}
      scope: invalid.deprecated.wolfram
    - match: System<*"`"*>{{undocumented_functions}}{{symbolEndBoundary}}
      scope: variable.function.undocumented.wolfram
    - match: System<*"`"*>{{experimental_functions}}{{symbolEndBoundary}}
      scope: variable.function.experimental.wolfram

    # all other unrecognized System<*"`"*> symbols
    - match: System<*"`"*>{{symbolSegment}}{{symbolEndBoundary}}
      scope: invalid.illegal.system.wolfram

    # all other Foo<*"`"*> qualified symbols
    - match: '{{symbolSegment}}(?:<*"`"*>{{symbolSegment}})+'
      scope: variable.other.wolfram
    # naked Foo<*"`"*>
    - match: '{{symbolSegment}}<*"`"*>'
      scope: invalid.illegal.wolfram

    # current context <*"`"*> qualified symbols
    - match: '(?:<*"`"*>{{symbolSegment}})+'
      scope: variable.other.wolfram
    # naked <*"`"*>
    - match: '<*"`"*>'
      scope: invalid.illegal.wolfram

    # System<*"`"*> unqualified symbols
    - match: '{{built_in_functions}}{{symbolEndBoundary}}'
      scope: variable.function.builtin.wolfram
    - match: '{{constants}}{{symbolEndBoundary}}'
      scope: constant.language.wolfram
    - match: '{{obsolete_functions}}{{symbolEndBoundary}}'
      scope: invalid.deprecated.wolfram
    - match: '{{undocumented_functions}}{{symbolEndBoundary}}'
      scope: variable.function.undocumented.wolfram
    - match: '{{experimental_functions}}{{symbolEndBoundary}}'
      scope: variable.function.experimental.wolfram

    # all other unqualified symbols
    - match: '{{symbolSegment}}'
      scope: variable.other.wolfram

  groups:
    - match: \\\(
      scope: punctuation.section.linearsyntax.begin.wolfram
      push:
        - meta_scope: meta.linearsyntax.wolfram
        - match: \\\)
          scope: punctuation.section.linearsyntax.end.wolfram
          pop: true
        - include: expressions
    - match: \\\)
      scope: invalid.illegal.stray-linearsyntax-end.wolfram
    - match: \(
      scope: punctuation.section.parens.begin.wolfram
      push:
        - meta_scope: meta.parens.wolfram
        - match: \)
          scope: punctuation.section.parens.end.wolfram
          pop: true
        - include: expressions
    - match: \)
      scope: invalid.illegal.stray-parens-end.wolfram
    - match: \[\s*\[
      scope: punctuation.section.parts.begin.wolfram
      push:
        - meta_scope: meta.parts.wolfram
        - match: \]\s*\]
          scope: punctuation.section.parts.end.wolfram
          pop: true
        - include: expressions
    - match: \]\s*\]
      scope: invalid.illegal.stray-parts-end.wolfram
    - match: \[
      scope: punctuation.section.brackets.begin.wolfram
      push:
        - meta_scope: meta.brackets.wolfram
        - match: \]
          scope: punctuation.section.brackets.end.wolfram
          pop: true
        - include: expressions
    - match: \]
      scope: invalid.illegal.stray-brackets-end.wolfram
    - match: \{
      scope: punctuation.section.braces.begin.wolfram
      push:
        - meta_scope: meta.braces.wolfram
        - match: \}
          scope: punctuation.section.braces.end.wolfram
          pop: true
        - include: expressions
    - match: \}
      scope: invalid.illegal.stray-braces-end.wolfram
    - match: <\|
      scope: punctuation.section.association.begin.wolfram
      push:
        - meta_scope: meta.association.wolfram
        - match: \|>
          scope: punctuation.section.association.end.wolfram
          pop: true
        - include: expressions
    - match: \|>
      scope: invalid.illegal.stray-association-end.wolfram

  pattern_operators:
    - match: ___
      scope: keyword.operator.BlankNullSequence.wolfram
    - match: __
      scope: keyword.operator.BlankSequence.wolfram
    - match: _\.
      scope: keyword.operator.Optional.wolfram
    - match: _
      scope: keyword.operator.Blank.wolfram

  out:
    - match: '%\d+'
      scope: keyword.other.Out.wolfram
    - match: '%+'
      scope: keyword.other.Out.wolfram

  slot:
    - match: '#[[:alpha:]][[:alnum:]]*'
      scope: keyword.other.Slot.wolfram
    #
    # this matches both ##123 cases and the single ## case
    #
    - match: '##\d*'
      scope: keyword.other.SlotSequence.wolfram
    #
    # this matches both #123 cases and the single # case
    #
    - match: '#\d*'
      scope: keyword.other.Slot.wolfram
